1. Sorting Algorithms

a) Bubble Sort [O(n^2) - worst case]

function bubbleSort(arr) {
  let n = arr.length;
  for (let i = 0; i < n - 1; i++) {
    for (let j = 0; j < n - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      }
    }
  }
  return arr;
}

console.log(bubbleSort([5,3,8,4,2]));



--------------------------------------

b) Insertion sort [O(n^2) - worst case, O(n) - best case ]

function insertionSort(arr){
    let n=arr.length;
    for(let i=1;i<n;i++){
        let key=arr[i];
        let j=i-1;
        while(j>=0 && arr[j]>key){
            arr[j+1]=arr[j];
            j--;
        }
        arr[j+1]=key;
    }
    return arr;
}


console.log(insertionSort([5, 3, 4, 1]));



--------------------------------------

c) Selection Sort  [O(n^2) - in all cases]


function selectionSort(arr){
    let n = arr.length;
    for(let i=0;i<n-1;i++){
        let minIdx = i;
        
        for(let j = i+1; j<n; j++){
            if(arr[j]<arr[minIdx]){
                minIdx=j;
            }
        }
        [arr[i],arr[minIdx]] = [arr[minIdx],arr[i]];
    }
    return arr;
}

console.log(selectionSort([5, 3, 8, 4, 2]));



-------------------------------------


d) Quick Sort  [O(n log n) - average, O(n^2) - worst]

function quickSort(arr){
    if(arr.length<=1) return arr;
    let pivot=arr[arr.length-1];
    let left=[], right=[];
    for(let i=0;i<arr.length-1;i++){
        if(arr[i]<pivot) left.push(arr[i]);
        else right.push(arr[i]);
    }
    return [...quickSort(left),pivot,...quickSort(right)];
}

console.log(quickSort([5, 3, 8, 4, 2]));



-----------------------------------------

e) Merge Sort [O(n log n) - all cases]

function mergeSort(arr) {
    if (arr.length <= 1) return arr; // Base case

    const mid = Math.floor(arr.length / 2); // Find middle
    const left = mergeSort(arr.slice(0, mid)); // Sort left half
    const right = mergeSort(arr.slice(mid));   // Sort right half

    return merge(left, right); // Merge sorted halves
}

function merge(left, right) {
    let sortedArray = [];
    let i = 0, j = 0;

    while (i < left.length && j < right.length) {
        if (left[i] <= right[j]) {
            sortedArray.push(left[i]);
            i++;
        } else {
            sortedArray.push(right[j]);
            j++;
        }
    }

    // Add remaining elements
    return [...sortedArray, ...left.slice(i), ...right.slice(j)];
}

console.log(mergeSort([5, 3, 8, 4, 2]));




===================================
===================================
===================================
===================================


2.Stack


class Stack{
    constructor(){
        this.items = [];
    }
    
    push(element){
        this.items.push(element);
        console.log(`${element} pushed to stack`);
    }
    
    pop(){
        if(this.items.length === 0){
            console.log("Stack Underflow");
            return null;
        }
        
        let removed = this.items.pop();
        console.log(`${removed} popped from stack`);
        return removed;
    }
    
    display(){
        console.log("Stack elements : ", this.items.join(", "));
    }
}

 const stack1 = new Stack();
 stack1.push(10);
 stack1.push(20);
 stack1.push(30);
 stack1.push(40);
 stack1.pop();
 stack1.display();



======================================
======================================
======================================
======================================

3. Queue


class Queue {
    constructor(){
        this.items = [];
    }
    
    enqueue(element){
        this.items.push(element);
        console.log(`${element} enqueued to queue`);
    }
    
    dequeue(){
        if(this.items.length === 0){
            console.log("Queue underflow");
            return null;
        }
        let removed = this.items.shift();
        console.log(`${removed} dequeued from queue`);
        return removed;
    }
    
    display(){
        console.log("Queue elements: ", this.items.join(", "));
    }
}


let queue1 = new Queue();
queue1.enqueue(10);
queue1.enqueue(20);
queue1.enqueue(30);
queue1.enqueue(40);
queue1.dequeue();
queue1.display();



======================================
======================================
======================================
======================================


4. Hash Table

,.,.,.,.,
class HashTable {
    constructor(size=5){
        this.table = new Array(size);
    }
    
    //Hash function
    _hash(key){
        let hash = 0;
        for(let char of key){
            hash = (hash+char.charCodeAt(0)) % this.table.length;
        }
        return hash;
    }
    
    //Insert key-value
    set(key,value){
        const index = this._hash(key);
        if(!this.table[index]){
            this.table[index] = [];
        }
        this.table[index].push([key,value]);
    }
    
    //Retrieve value
    get(key){
        const index = this._hash(key);
        const bucket = this.table[index];
        if(bucket){
            for(let [k,v] of bucket){
                if(k===key) return v;
            }
        }
        return undefined;
    }
    
    //Delete key-value
    remove(key){
        const index = this._hash(key);
        const bucket = this.table[index];
        if(bucket){
            this.table[index] = bucket.filter((k,_) => k !== key);
        }
    }
    
    display(){
        console.log(this.table);
    }
}

const ht = new HashTable();
ht.set("apple",100);
ht.set("banana",50);
ht.set("orange",80);
ht.set("grape",150);


console.log(ht.get("banana"));
console.log(ht.get("grape"));
ht.display();



==========================
=========================-
========================
========================
//Double ended queue

class Queue{
    constructor(){
        this.items=[];
    }
    
    addBack(x){
        this.items.push(x);
    }
    
    removeFront(){
        this.items.shift();
    }
    
    peekFront(){
        return this.items[0];
    }
    
    addFront(x){
        this.items.unshift(x);
    }
    
    removeBack(){
        this.items.pop();
    }
    
    peekBack(){
        return this.items[this.items.length-1];
    }
}


const q1 = new Queue();
q1.addBack(10);
q1.addBack(20);
q1.addBack(30);
q1.addBack(40);
q1.addFront(100);
q1.addBack(1000);
q1.removeBack();
console.log(q1);




==========================
=========================

//Circular queue
class Queue{
    constructor(k){
        this.size=k;
        this.items=[];
    }
    
    enqueue(value){
        if(this.items.length === this.size){
            return false;
        }
        this.items.push(value);
    }
    
    rear(){
        return this.items[this.items.length-1]
    }
    
    front(){
        return this.items[0];
    }
    
    
}

const q1 = new Queue(5);
q1.enqueue(10);
q1.enqueue(20);
q1.enqueue(30);
q1.enqueue(40);
q1.enqueue(50);
q1.enqueue(60);
console.log(q1.front());
console.log(q1.rear());









double ended queue



addressing collision:
separate chaining - (linked list, array)
open addressing - linear probing, quadratic probing, double hashing

load factor - (eg:7/10)
rehashing - increasing the size

stack using linked list
queue using linked list







==============================
==============================
==============================
==============================

week2 review1 [19-08-2025]
// class HashTable{
//     constructor(size=5){
//         this.table=new Array(size);
//     }
    
//     _hash(key){
//         let hash = 0;
//         for(let char of key){
//             hash = (hash+char.charCodeAt(0))% this.table.length;
//         }
//         return hash;
//     }
    
//     set(key,value){
//         let index = this._hash(key);
//         if(!this.table[index]){
//             this.table[index]=[];
//         }
        
//         let bucket = this.table[index];
//         // if(this.table[index].includes([key,value])){
//         //     this.table[index] = bucket.filter(([k,_])=> k !== key);
//         // }
//         if(bucket){
//             this.table[index]= bucket.filter(([k,_])=>k !==key);
//         }
//         this.table[index] = this.table[index].push([key,value]);
        
//     }
    
//     remove(key){
//         let index = this._hash(key);
//         let bucket = this.table[index];
//         if(bucket){
//             this.table[index] = bucket.filter(([k,_])=>k !== key);
//         }
//     }
    
//     display(){
//         console.log(this.table);
//     }
    
// }

// const ht = new HashTable();
// ht.set("orange",100);
// ht.set("apple",200);
// ht.set("banana",300);
// ht.set("mango",400);
// ht.display();
// console.log("========");

// ht.remove("apple");
// ht.display();

// ht.set("orange",200);


function(str){
    for(let char of str){
        let count=0;
        let result="";
        if(char !== " "{
            count++;
            index = index+char;
        } else if( char === " " ){
            count=0;
            index = 
            
        }
    }
}


let str = "I am ashok";



===================================
===================================
===================================
===================================


Queue using Stack

class MyQueue{
    constructor(){
        this.stack1=[];
        this.stack2=[];
    }
    
    push(element){
        this.stack1.push(element);
    }
    
    pop(){
        if(!this.stack2.length){
            while(this.stack1.length){
                this.stack2.push(this.stack1.pop());
            }
        }
        return this.stack2.pop();
    }
    
    peek(){
        if(!this.stack2.length){
            while(this.stack1.length){
                this.stack2.push(this.stack1.pop());
            }
        }
        return this.stack2[stack2.length-1];
    }
    
    display(){
        if(this.stack1.length){
            while(this.stack1.length){
                this.stack2.push(this.stack1.pop());
            }
        }
        if(!this.stack1.length){
            while(this.stack2.length){
                this.stack1.push(this.stack2.pop());
            }
        }
        console.log(this.stack1);
    }
}

const qu = new MyQueue();
qu.push(10);
qu.push(20);
qu.push(30);
qu.push(40);
qu.pop();
qu.display();




=================================
=================================
=================================
=================================


Q. Find the first non-repeating character in a string using a hash table

function firstNonrepeatingChar(str){
   let map = new Map();
   
   for(let char of str){
       map.set(char,(map.get(char) || 0)+1);
   }
   
   for(let [char,count] of map){
       if(count===1){
           return char;
       }
   }
   
   return null;
}

console.log(firstNonrepeatingChar("aabbcd"));




=================================
=================================
=================================
=================================


Q. Find the least occurred number using a hash table

function leastOccuredNumber(arr){
    let map = new Map();
    let smallestNum=null;
    let freq=Infinity;
    for(let num of arr){
        map.set(num,(map.get(num)||0)+1)
    }
    
    for(let [k,v] of map){
        if(v<freq){
            smallestNum=k;
            freq=v;
        }
    }
    return smallestNum
}

let arr = [3,6,2,3,5,2,7];

console.log(leastOccuredNumber(arr));



==============================
==============================
==============================
==============================



Q. sorting a stack


function sortStack(stack){
    let tempStack = [];
    
    while(stack.length>0){
        let temp = stack.pop();
        
        while(tempStack.length>0 && tempStack[tempStack.length - 1] > temp){
            stack.push(tempStack.pop());
        }
        
        tempStack.push(temp);
    }
    
    return tempStack;
}

let stack = [2,7,4,3,8];

console.log(sortStack(stack));



===============================
===============================
===============================
===============================


Queue using LinkedList


class Node{
    constructor(value){
        this.value=value;
        this.next=null;
    }
}

class Queue{
    constructor(){
        this.front=null;
        this.rear = null;
        this.size = 0;
    }
    
    enqueue(value){
        const newNode = new Node(value);
        
        if(!this.rear){
            this.front = this.rear = newNode;
        }else{
            this.rear.next = newNode;
            this.rear = newNode;
        }
        
        this.size++;
    }
    
    dequeue(){
        if(!this.front) return null;
        
        const removedValue = this.front.value;
        this.front = this.front.next;
        
        if(!this.front){
            this.rear=null;
        }
        
        this.size--;
        
        return removedValue;
    }
    
    peek(){
        return this.front?this.front.value:null;
    }
    
    isEmpty(){
        return this.size === 0;
    }
    
    getSize(){
        return this.size;
    }
    
    print(){
        let current = this.front;
        while(current){
            console.log(current.value);
            current = current.next;
        }
        
    }
}

const q = new Queue();
q.enqueue(10);
q.enqueue(20);
q.enqueue(30);
q.enqueue(40);
q.print();




=========================
=========================
=========================
=========================



Stack using LinkedList

class Node{
    constructor(value){
        this.value=value;
        this.next=null;
    }
}

class Stack{
    constructor(){
        this.top = null;
        this.size = 0;
    }
    
    push(value){
        const newNode = new Node(value);
        newNode.next = this.top;
        this.top = newNode;
        this.size++;
    }
    
    pop(){
        if(!this.top) return null;
        
        const removedValue = this.top.value;
        this.top = this.top.next;
        this.size--;
        return removedValue;
    }
    
    peek(){
        return this.top?this.top.value:null;
    }
    
    isEmpty(){
        return this.size===0;
    }
    
    getSize(){
        return this.size;
    }
    
    print(){
        let current = this.top;
        while(current){
            console.log(current.value);
            current=current.next;
        }
    }
    
}

const st = new Stack();
st.push(10);
st.push(20);
st.push(30);
st.push(40);
st.print();




=========================
=========================
=========================
=========================

Q. Second smallest word in a string

let str = "I am Ashok";

function words(str){
    let res=[];
    let ch = "";
    for(let char of str){
        if(char === " "){
            res.push(ch);
            ch="";
        }else{
            ch=ch+char;
        }
    }
    if(ch!=="") res.push(ch);
    
    return res;
}


function secondSmallest(str){
    let array = words(str);
    
    let smallest="";
    let secondSmallest="";
    
    for(let word of array){
        
        if(smallest.length===0 || word.length < smallest.length){
            secondSmallest=smallest;
            smallest = word;
        }else if(secondSmallest.length===0 || word.length < secondSmallest.length){
            secondSmallest=word;
        }
    }
    
    return secondSmallest;
}

console.log(secondSmallest(str));



=========================
=========================
=========================
=========================



DSA2 - review2 [26.08.2025]

// function quickSort(arr){
//     if(arr.length<=1) return arr;
    
//     let pivot = arr[arr.length-1];
    
//     let left = [];
//     let right = [];
    
//     for(let i=0;i<arr.length-1;i++){
//         if(arr[i]<pivot){
//             left.push(arr[i]);
//         }else{
//             right.push(arr[i]);
//         }
//     }
    
//     return [...quickSort(left),pivot,...quickSort(right)];
// }

// let arr = [5,2,8,3,7];
// console.log(quickSort(arr));


// class Node{
//     constructor(value){
//         this.value=value;
//         this.next=null;
//         this.prev=null;
//     }
// }


// class Stack{
//     constructor(){
//         this.top=null;
//         this.size=0;
//     }
    
//     push(elem){
//         const newNode = new Node(elem);
//         if(!this.top) {
//             return this.top = newNode;
//             this.next=
//             size++;
//         }
//         this.top.next = newNode;
//         newNode = this.top;
//         size++;
        
//     }
    
//     pop(){
//         if(!this.top) return null;
//         let removed = this.top.value;
//         size--;
//         return removed;
//     }
// }


// class Queue{
//     constructor(){
//         this.items=[];
//     }
    
//     enqueue(elem){
//         this.items.push(elem);
//     }
    
//     dequeue(){
//         this.items.shift();
//     }
    
//     display(){
//         console.log(this.items.join(", "));
//     }
// }

// const qu = new Queue();

// qu.enqueue(10);
// qu.enqueue(20);
// qu.enqueue(30);
// qu.enqueue(40);
// qu.dequeue();
// qu.display();


// class HashTable{
//     constructor(size=5){
//         this.table=new Array(size);
//     }
    
//     _hash(key){
//         let hash = 0;
//         for(let char of key){
//             hash = (hash+char.charCodeAt(0)) % this.table.length;
//         }
//         return hash;
//     }
    
//     set(key,value){
//         let index = this._hash(key);
        
//         if(!this.table[index]){
//             this.table[index]=[];
//         }
//         this.table[index].push([key,value]);
//     }
    
//     display(){
//         console.log(this.table);
//     }
// }

// const ht = new HashTable(5);
// ht.set("apple",100);
// ht.set("mango",150);
// ht.set("orange",200);
// ht.display();


// function mergeSort(arr){
//     if(arr.length<=1) return arr;
    
//     let mid = Math.floor(arr.length/2);
    
//     let left = mergeSort(arr.slice(0,mid));
//     let right = mergeSort(arr.slice(mid));
    
//     return merge(left,right);
// }

// function merge(left,right){
//     let sortedArray = [];
//     let i=0,j=0;
    
//     while(i<left.length && j<right.length){
//         if(left[i]>=right[j]){
//             sortedArray.push(left[i]);
//             i++;
//         }else{
//             sortedArray.push(right[j])
//             j++;
//         }
//     }
    
//     return [...sortedArray,...left.slice(i),...right.slice(j)];
// }


// let arr=[5,1,8,3,9];
// console.log(mergeSort(arr));








































